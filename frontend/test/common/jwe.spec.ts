import { base64, base64url } from 'rfc4648';
import { beforeEach, describe, expect, it } from 'vitest';
import { ConcatKDF, ECDH_ES, ECDH_P384, EncryptedJWE, JWE, JWEHeader, PBES2, Recipient } from '../../src/common/jwe';

describe('JWE', () => {
  describe('NIST SP 800-56A Rev. 2 Section 5.8.1', () => {
    it('should fulfill test vectors', async () => {
      const z = new Uint8Array([158, 86, 217, 29, 129, 113, 53, 211, 114, 131, 66, 131, 191, 132, 38, 156, 251, 49, 110, 163, 218, 128, 106, 72, 246, 218, 167, 121, 140, 254, 144, 196]);
      const algorithmId = new Uint8Array([0, 0, 0, 7, 65, 49, 50, 56, 71, 67, 77]);
      const partyUInfo = new Uint8Array([0, 0, 0, 5, 65, 108, 105, 99, 101]);
      const partyVInfo = new Uint8Array([0, 0, 0, 3, 66, 111, 98]);
      const suppPubInfo = new Uint8Array([0, 0, 0, 128]);

      const otherInfo = new Uint8Array([...algorithmId, ...partyUInfo, ...partyVInfo, ...new Uint8Array(suppPubInfo)]);
      const derivedKey = await ConcatKDF.kdf(z, 16, otherInfo);
      expect(new Uint8Array(derivedKey)).toEqual(new Uint8Array([86, 170, 141, 234, 248, 35, 109, 32, 92, 34, 40, 205, 113, 167, 16, 26]));
    });
  });

  describe('JWE serialization for single recipient', () => {
    const jwe = new EncryptedJWE('protectedHeader', [{ encrypted_key: 'encryptedKey', header: { kid: 'alice' } }], 'iv', 'ciphertext', 'tag');

    it('compactSerialization', () => {
      const token = jwe.compactSerialization();

      expect(token).to.eq('protectedHeader.encryptedKey.iv.ciphertext.tag');
    });

    it('jsonSerialization', () => {
      const token = jwe.jsonSerialization();

      expect(token.protected).to.eq('protectedHeader');
      expect(token.iv).to.eq('iv');
      expect(token.ciphertext).to.eq('ciphertext');
      expect(token.tag).to.eq('tag');
      expect(token.recipients[0].encrypted_key).to.eq('encryptedKey');
      expect(token.recipients[0].header.kid).to.eq('alice');
    });
  });

  describe('JWE serialization for multiple recipients', () => {
    const recipients = [
      { encrypted_key: 'encryptedKey1', header: { kid: 'alice' } },
      { encrypted_key: 'encryptedKey2', header: { kid: 'bob' } }
    ];
    const jwe = new EncryptedJWE('protectedHeader', recipients, 'iv', 'ciphertext', 'tag');

    it('compactSerialization', () => {
      expect(jwe.compactSerialization).to.throw();
    });

    it('jsonSerialization', () => {
      const token = jwe.jsonSerialization();

      expect(token.protected).to.eq('protectedHeader');
      expect(token.iv).to.eq('iv');
      expect(token.ciphertext).to.eq('ciphertext');
      expect(token.tag).to.eq('tag');
      expect(token.recipients[0].encrypted_key).to.eq('encryptedKey1');
      expect(token.recipients[0].header.kid).to.eq('alice');
      expect(token.recipients[1].encrypted_key).to.eq('encryptedKey2');
      expect(token.recipients[1].header.kid).to.eq('bob');
    });
  });

  describe('JWE using alg: ECDH-ES+A256KW', () => {
    it('x = decrypt(encrypt(x, pubKey), privKey)', async () => {
      // pkcs8: ME8CAQAwEAYHKoZIzj0CAQYFK4EEACIEODA2AgEBBDEA6QybmBitf94veD5aCLr7nlkF5EZpaXHCfq1AXm57AKQyGOjTDAF9EQB28fMywTDQ:
      const publicKeyJwk: JsonWebKey = {
        kty: 'EC',
        crv: 'P-384',
        x: 'RxQR-NRN6Wga01370uBBzr2NHDbKIC56tPUEq2HX64RhITGhii8Zzbkb1HnRmdF0',
        y: 'aq6uqmUy4jUhuxnKxsv59A6JeK7Unn-mpmm3pQAygjoGc9wrvoH4HWJSQYUlsXDu'
      };
      const privateKeyJwk: JsonWebKey = {
        ...publicKeyJwk,
        d: '6QybmBitf94veD5aCLr7nlkF5EZpaXHCfq1AXm57AKQyGOjTDAF9EQB28fMywTDQ'
      };
      const recipientPublicKey = await crypto.subtle.importKey('jwk', publicKeyJwk, ECDH_P384, false, []);
      const recipientPrivateKey = await crypto.subtle.importKey('jwk', privateKeyJwk, ECDH_P384, true, ['deriveBits']);

      const orig = { hello: 'world' };

      const jwe = await JWE.build(orig).encrypt(Recipient.ecdhEs('alice', recipientPublicKey));

      const decrypted = await jwe.decrypt(Recipient.ecdhEs('alice', recipientPrivateKey));
      expect(decrypted).to.deep.eq(orig);
    });

    it('decrypt ECDH-ES', async () => {
      // JWE generated by https://dinochiesa.github.io/jwt/
      const jwe = 'eyJhbGciOiJFQ0RILUVTIiwiZW5jIjoiQTI1NkdDTSIsImVwayI6eyJrdHkiOiJFQyIsImNydiI6IlAtMjU2IiwieCI6InpMYlRUN3M5d3lZeGpHdGZxeHVDQk81TTNTMTlNRzJHUGJzTlJhMFEwT2MiLCJ5IjoiTGpmVG9jLXpIcWRqcHA4VURPSl9aS1JLQ0FoSGpSSmFGS0FJbjdTR1RXdyJ9fQ..30WmoR8Qp1VA5NMr.TBRC30hVRwi_W_HIe03JWNY.zvfl5wQuG8vhUjhr1-f8jQ';
      const rawRecipientPrivateKey = base64.parse('MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgzMoA2cm0rNRLA3zZa2VzYxd1QLFTdOxsMQ+6V6faoLmhRANCAAR4M7kZS/VdkdOQG56ELvL2/3L8ti+yQeQBv0BuyUJqWHMOv13VLZOKTnvtFrAZbjM6lONayft9qSr43thfj1Pb', { loose: true });
      const recipientPrivateKey = await crypto.subtle.importKey('pkcs8', rawRecipientPrivateKey, { name: 'ECDH', namedCurve: 'P-256' }, false, ['deriveBits']);
      const orig = { hello: 'world' };
      const recipient = Recipient.ecdhEs('alice', recipientPrivateKey);

      const decrypted = await JWE.parseCompact(jwe).decrypt(recipient);
      expect(decrypted).to.deep.eq(orig);
    });

    it('decrypt ECDH-ES+A256KW 1', async () => {
      // JWE generated by https://dinochiesa.github.io/jwt/
      const jwe = 'eyJlcGsiOnsia3R5IjoiRUMiLCJjcnYiOiJQLTI1NiIsIngiOiJGX3lIQWlEQkNMajdVdW43NXZtTGpsSkRnSFRmVnFPUW51X0g0cGhNbjVZIiwieSI6IlFMRThtd1V2M0tDU3pjNmtqT0R2QnhEQjFqRFdUVnE1N052UlpUcFZNZFUifSwiZW5jIjoiQTI1NkdDTSIsImFsZyI6IkVDREgtRVMrQTI1NktXIn0.ziLX2llBDAO0Ha_EV2QyLVGo47qN0c2QpSt-tu35yn8t6Q-elpVG3A.QXT0c27wNHVbvcQN.z82EXvOQ_IWaCGcSmlizzFY.JkrlVlJin8E4uH4WEjPs0w';
      const rawRecipientPrivateKey = base64.parse('MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg8w/B3QWfLRwtt+pCYScLE8CzqWOYGYl/t2gwmb89AA2hRANCAAR/S7NvYpmAinsrGaDaFNmN8eQFRpwc5alP4Clu8hV//hcrN9DMHGbO2lsKk//ktpUNXt4Fj4UIsBw3ABUchbxI', { loose: true });
      const recipientPrivateKey = await crypto.subtle.importKey('pkcs8', rawRecipientPrivateKey, { name: 'ECDH', namedCurve: 'P-256' }, false, ['deriveBits']);
      const orig = { hello: 'world' };
      const recipient = Recipient.ecdhEs('alice', recipientPrivateKey);

      const decrypted = await JWE.parseCompact(jwe).decrypt(recipient);
      expect(decrypted).to.deep.eq(orig);
    });

    // 

    it('decrypt ECDH-ES+A256KW 2', async () => {
      // JWE generated by nimbus-jose-jwt
      const jwe = 'eyJlcGsiOnsia3R5IjoiRUMiLCJjcnYiOiJQLTM4NCIsIngiOiJDMndad2lrUUc2NFVjNWdHRHV4VWhVb0dHbEpDVnI4ZHFjMFZkelZIUDl3WUtmSTNCYl8tVnQ3VGtfRER5N1RoIiwieSI6IlNTMTNRS18wLWJYQ1J4OHkyZXFETUNPU0I5OUhqOGtHQWh3b2hzWmwwYi1vamdiTzBsNUpKQW4wYmFCTWE4d1YifSwiZW5jIjoiQTI1NkdDTSIsImFsZyI6IkVDREgtRVMrQTI1NktXIn0.VZPzMmLm31EfxoOhVmLRIu0ILMs473FKeLd8jhaCrzHlLhXS0S2VSA.7W9iNEn-1B1PnfuQ.6y_7YaOXUCCXvuaxwbHLtpc.yHRzBceUHw6huMv4jFApxg';
      const privateKeyJwk: JsonWebKey = { 'kty': 'EC', 'crv': 'P-384', 'x': 'I47LcQjeZZ5_HxIbw3e5nwaA2S7BFr0CFfiGaay9q3OTNNxFm-O4pjQ2wntSS3hu', 'y': 'mDFWsM-fkpHpM6JmJczl31PkjrfCbz6B_IhYcMKsJc3NBIO1ALRvmsjrX0aTRH_e', 'd': 'tgit5ED1PpM6rwIDqMovYkKSZ8n5V05wc_sHi-AiqwM9atiTsO3w2E2wDa-L1lFN' };
      const privateKey = await crypto.subtle.importKey('jwk', privateKeyJwk, { name: 'ECDH', namedCurve: 'P-384' }, false, ['deriveBits']);
      const orig = { hello: 'world' };
      const recipient = Recipient.ecdhEs('alice', privateKey);

      const decrypted = await JWE.parseCompact(jwe).decrypt(recipient);
      expect(decrypted).to.deep.eq(orig);
    });
  });

  describe('JWE using alg: PBES2-HS512+A256KW', () => {
    it('x = decrypt(encrypt(x, pass), pass)', async () => {
      const orig = { hello: 'world' };
      const recipient = Recipient.pbes2('password', 'topsecret', 1000);

      const jwe = await JWE.build(orig).encrypt(recipient);

      const decrypted = await jwe.decrypt(recipient);
      expect(decrypted).to.deep.eq(orig);
    });

    it('encrypt JWE used in Java unit tests', async () => {
      const orig = { key: 'ME8CAQAwEAYHKoZIzj0CAQYFK4EEACIEODA2AgEBBDEA6QybmBitf94veD5aCLr7nlkF5EZpaXHCfq1AXm57AKQyGOjTDAF9EQB28fMywTDQ' };

      const recipient = Recipient.pbes2('password', '123456', 1000);
      const jwe = await JWE.build(orig).encrypt(recipient);
      const token = jwe.compactSerialization();

      expect(token).not.to.be.null;
    });

    it('decrypt PBES2-HS512+A256KW', async () => {
      // JWE generated by nimbus-jose-jwt
      const jwe = 'eyJwMnMiOiI1REp2cFJVTzJkOWlUdjdHc24wTlp3IiwicDJjIjoxMDAwLCJlbmMiOiJBMjU2R0NNIiwiYWxnIjoiUEJFUzItSFM1MTIrQTI1NktXIn0.uOPjfcgWobRPtoO124qLyv9XSRWEw1rmdzDqroH6iTBQyyNMKIjdPw.dIH9LVbMH5aAmCMj.hsIdH2JSliAV2ueFErovkHY.OA2nayTnJYTQO04HGvlaMA';
      const orig = { hello: 'world' };

      const recipient = Recipient.pbes2('password', 'topsecret');

      const decrypted = await JWE.parseCompact(jwe).decrypt(recipient);
      expect(decrypted).to.deep.eq(orig);
    });
  });

  describe('JWE using alg: A256KW', () => {
    it('x = decrypt(encrypt(x, kek), kek)', async () => {
      const kek = await crypto.subtle.generateKey({ name: 'AES-KW', length: 256 }, false, ['wrapKey', 'unwrapKey']);
      const orig = { hello: 'world' };
      const recipient = Recipient.a256kw('kw', kek);

      const jwe = await JWE.build(orig).encrypt(recipient);

      const decrypted = await jwe.decrypt(recipient);
      expect(decrypted).to.deep.eq(orig);
    });

    it('decrypt', async () => {
      // JWE generated by https://dinochiesa.github.io/jwt/
      const jwe = 'eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2R0NNIn0.JTSrGbw4XEKXYFTC7siTT7DIZUX2SogThcLKXgxe0FPK3Fi8ckjr9A.zQx0t4qoTVIc-h5f.cmqzZ-md3cvdTNH9FWbKOsw.DCdGhmdwjoYKIuNC5zgQJQ';
      const rawKek = base64url.parse('y_uxz8iAtcOXlqMYpm2jASvDWokpCYMtwkthFSK6IF0', { loose: true });
      const kek = await crypto.subtle.importKey('raw', rawKek, 'AES-KW', false, ['unwrapKey']);
      const orig = { hello: 'world' };
      const recipient = Recipient.a256kw('kw', kek);

      const decrypted = await JWE.parseCompact(jwe).decrypt(recipient);
      expect(decrypted).to.deep.eq(orig);
    });
  });

  describe('PBES2', () => {
    /**
     * Test vectors from https://www.rfc-editor.org/rfc/rfc7517#appendix-C.4
     */
    it('should derive expected key using PBES2', async () => {
      const saltInput = Uint8Array.of(217, 96, 147, 112, 150, 117, 70, 247, 127, 8, 155, 137, 174, 42, 80, 215);
      const iterations = 4096;
      const password = 'Thus from my lips, by yours, my sin is purged.';

      const wrappingKey = await PBES2.deriveWrappingKey(password, 'PBES2-HS256+A128KW', saltInput, iterations, true);
      const rawKey = await crypto.subtle.exportKey('raw', wrappingKey);
      expect(new Uint8Array(rawKey)).toEqual(Uint8Array.of(110, 171, 169, 92, 129, 92, 109, 117, 233, 242, 116, 233, 170, 14,
        24, 75));
    });
  });

  describe('ECDH_ES', () => {
    // Test vectors from https://www.rfc-editor.org/rfc/rfc7518#appendix-C
    const alicePub: JsonWebKey = {
      kty: 'EC',
      crv: 'P-256',
      x: 'gI0GAILBdu7T53akrFmMyGcsF3n5dO7MmwNBHKW5SV0',
      y: 'SLW_xSffzlPWrHEVI30DHM_4egVwt3NQqeUD7nMFpps'
    };
    const alicePriv: JsonWebKey = {
      ...alicePub,
      d: '0_NxaRPUMQoAJt50Gz8YiTr8gRTwyEaCumd-MToTmIo'
    };
    let alice: CryptoKey;
    const bobPub: JsonWebKey = {
      kty: 'EC',
      crv: 'P-256',
      x: 'weNJy2HscCSM6AEDTDg04biOvhFhyyWvOHQfeF_PxMQ',
      y: 'e8lnCO-AlStT-NJVX-crhB7QRYhiix03illJOVAOyck'
    };
    let bob: CryptoKey;

    beforeEach(async () => {
      const importParams: EcKeyImportParams = { name: 'ECDH', namedCurve: 'P-256' };
      alice = await crypto.subtle.importKey('jwk', alicePriv, importParams, false, ['deriveBits']);
      bob = await crypto.subtle.importKey('jwk', bobPub, importParams, false, []);
      expect(alice.type).toEqual('private');
      expect(bob.type).toEqual('public');
    });

    it('should derive expected key using ECDH-ES', async () => {
      // Test vectors from https://www.rfc-editor.org/rfc/rfc7518#appendix-C
      const apu = new Uint8Array([65, 108, 105, 99, 101]);
      const apv = new Uint8Array([66, 111, 98]);
      const header: JWEHeader = {
        alg: 'ECDH-ES', // not relevant for this test
        enc: 'A128GCM',
        epk: alicePub,
        apu: base64url.stringify(apu, { pad: false }),
        apv: base64url.stringify(apv, { pad: false })
      };
      const derived = await ECDH_ES.deriveContentKey(bob, alice, 256, 16, header, true);
      const derivedBytes = await crypto.subtle.exportKey('raw', derived);
      expect(new Uint8Array(derivedBytes)).toEqual(new Uint8Array([86, 170, 141, 234, 248, 35, 109, 32, 92, 34, 40, 205, 113, 167, 16, 26]));
    });

    it('should derive content key despite missing apu/apv', async () => {
      const header: JWEHeader = {
        alg: 'ECDH-ES', // not relevant for this test
        enc: 'A128GCM',
        epk: alicePub,
        apu: undefined,
        apv: undefined
      };
      const derived = await ECDH_ES.deriveContentKey(bob, alice, 256, 16, header, true);
      const derivedBytes = await crypto.subtle.exportKey('raw', derived);
      expect(new Uint8Array(derivedBytes)).toEqual(new Uint8Array([187, 151, 171, 93, 14, 133, 109, 143, 143, 192, 62, 38, 91, 36, 42, 125]));
    });
  });
});
